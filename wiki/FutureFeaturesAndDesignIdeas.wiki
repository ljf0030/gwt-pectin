#summary A place to collect future features and design ideas.
#labels Featured

= Future features and design ideas =

Things that would be nice:

= Pectin Core =
==Field bindings==
It would be nice to support !ValueModelProviders that have type aware keys.  That way I can use something like `FieldModel<String> name = fieldBoundTo(provider, key)`'.  The `fieldOfType(..)` syntax would still exist for form only values etc.

==Widget Bindings==
Would probably nice to add value interceptors to the bindings.  This would be a more formalised way for watermarks to change the displayed value under certain conditions. 

==Formatted fields==
Currently formatted fields don't get a chance to re-format the value the user entered with out using a deferred command (since the binding ignores model changes during the update).  The formatted field could probably handle this internally by checking the text version with a freshly formatted version and doing the deferred command thing itself, but I'd rather not use a deferred command at all if possible.   


= Plugins =
==!SelectionPlugin== 
Bring focus/blur and field selection into the presentation layer.  `selectionModel.addSelectionHandler(...)`, `selectionModel.select(firstName)`.  A typical use case would be focussing a field with validation errors.  I would imagine something like `selectionModel.select(validationManager.getFirstFieldWithErrors())`.  There are issues to consider here with multi-field widgets etc but by using nested form models I think we can get around most cases.

==!ValidationPlugin enhancements== 
Proper async validation support, see DesignAsynchronousValidation.

Would also nice to support validation triggers like ON_BLUR, ON_EDIT etc.

==!UndoPlugin==
Wouldn't be too hard to implement at least basic undo/redo support.  Could also work with the selection model if required.

=Gui Actions/Message Display=
More advanced !ClickHanlders (like Swing Actions but better) that support enabled & visible state along with interceptors, delegates and listeners etc.  Would also update the !WidgetBinder to support `bind(action).to(button)`.  

These would need to support async interception (i.e. `onBeforeExecute(Intercept)`) for promting users and listeners for responding to execution progress and such.  Interception would need to async friendly and probably support chaining.  This kind of thing also typically needs to access "view services" like a promp/message service (like JOptionPane in swing... but better) so your action can interact with the users in a view independant manner, i.e. `messageDisplay.ask(question, callback, Options.OK, Option.CANCEL)`.  Standard services can then have implementation specific to your project or form.  

An async Gui Action may look something like the following.  Any button bound to it would disable during the execution, it would also provide an `ValueModel<Boolean> inProgressModel()` for use in the view (to show the spinny things).  The !MessageService is the callback into the view layer to ask questions and prompt the user:
{{{
private class GenerateAccessCodeAction extends AsyncGuiAction<String>
{
   private MyRemoveServiceAsync remoteService;
   private MessageDisplay messageDisplay;

   private GenerateAccessCodeAction()
   {
     setDisableWhileExecuting(true);
   }

   @Override
   protected void onBeforeExecute(Intercept action)
   {
      messageDisplay.ask("Do you really wish to generate a new access code?",
                         "Changing the access code will prevent access using the old code.",
                         "These changes will take effect after you save your changes.")
         .onChoosingDestructiveOption("Yes change the access code").then(action.proceed())
         .onChoosingDefault(Option.CANCEL_OPTION).then(action.cancel())
         .show();
   }

   @Override
   protected void doExecute(AsyncCallback<String> callback)
   {
      remoteServiceAsync.generateAccessCode(callback);
   }

   @Override
   protected void onSuccess(String accessCode)
   {
      // update our access code value model, I'm presuming this action is an 
      // inner of our form model, otherwise it'd have to be passed into us.
      accessCode.setValue(accessCode);
   }

   @Override
   protected void onFailure(Throwable error)
   {
      messageDisplay.showError("There was a problem generating a new code.", 
                         "Please try again.")
         .onChoosingDefault(Option.OK_OPTION).thenClose()
         .show();
   }

   @Override
   protected void onCancel() 
   {
      // we could do something here if we wanted.
   } 
}
}}}



=Would Like to but...=
== Native !UiBinder support==
Not even sure if it's possible yet.

==Integration with Drag&Drop layout tools==
And in my dreams... it would be to drag value models onto widgets and have the bind(model.name).to(firstName) automagically done.  I'd get to use visual layout tool (where it makes sense) and keep my OO models...