#summary A place to collect future features and design ideas.
#labels Featured

= Future features and design ideas =

Things that would be nice:

= Pectin Bindings =
== Support more generalised bindings of regular !ValueModels and !ListModels==  
I'd also like to support binding directly to `ValueModel` and `ListModel` for the cases where you don't need the additional functionalities (or overhead) of forms and plugins.

*This will be implemented in 0.8.*

==Controllers==
I'm slowly starting to create some standard controllers that I'd like to incorporate into Pectin (in the style of Cocoa/!SproutCore etc).  Using Controllers in conjunction with Value/!ListModel bindings allows some pretty complex behaviour to be built pretty quickly. 

The following is a very quick example of a !MasterDetail controller that binds a !SelectionControllers selected value to an !EditorController.  Selection changes are intercepted to prompt the user to save changes if required.
{{{
public class MasterDetailController {

  SingleSelectionController<Person> selectionController = ...;
  EditorController<Person> editorController = ...;
  Binder binder = new Binder();
  
  public MasterController() {
     
    // bind the selection to our editor
    binder.bind(selectionController.selection()).to(editorController);  

    // intercept selection changes and promt the user if there are 
    // unsaved changes..
    selectionController.selection().interceptUsing(new Interceptor() {
      public void intercept(Invocation invocation) {
        if (editorController.isDirty()) {
          // promt the user in an async/non-blocking way.
          messageService.ask("Do you want to discard you changes?")
            .onChoosingDestructive("Discard Changes")
              .thenExecute(invocation.getProceedCommand())
            .onChoosing("Cancel")
              .thenClose()
            .show();
        } else {
          // no unsaved changes so proceed imeadiatly.  The selection will
          // update and the binding will update the editorController.
          invocation.proceed();
        }
      }
    }
  }
}
// * `messageService` not included.
}}}

Some example controllers would be:
  * !SingleSelectionController & !MultiSelectionController
  * !EditorController - edits stuff.  Exposes models like `ValueModel<Boolean> dirty()` and `ValueModel<Boolean> editing()` along with `validate()`, `commit()` methods etc.
  * !EditorListController - handles binding of a `ListModels<T>` using a `Provider<EditorController<T>>` as an editor factory.  Could/would use an incremental command to build the UI and expose a `ValueModel<Boolean> busy()` that can be used to 'do stuff' tm. 
  * !WorkflowController - handles wizard like stuff.

= Forms =
==Field bindings==
It would be nice to support !ValueModelProviders that have type aware keys.  That way I can use something like `FieldModel<String> name = fieldBoundTo(provider, key)`.  The `fieldOfType(String.class).boundTo/create` syntax would still remain for existing use cases. 

==Form Bindings==
Would probably nice to add value interceptors to the bindings.  This would be a more formalised way for watermarks to change the displayed value under certain conditions. 

==Formatted fields==
Currently formatted fields don't get a chance to re-format the value the user entered with out using a deferred command (since the binding ignores model changes during the update).  The formatted field could probably handle this internally by checking the text version with a freshly formatted version and doing the deferred command thing itself, but I'd rather not use a deferred command at all if possible.   

==!BeanModelProvider Wish List== 
===Validation Support===
It would be nice if !BeanModelProvider supported JSR 303 style validation.  This would allow a reflection variant of the provider to be used on the server to perform validation.  This is a fair bit of work but would support unified server side and client side validation.  I'm holding off on this to see how Google's !ValueStore proceeds.  I'm also not sure how to handle conditional validation.

===Diffs===
It might be possible for the provider to support 'diffing' between two beans.  This would allow you to present what has changed to the user when handling stale entity exceptions.

===Compile Time Safety===
It might also also be possible to support compile time type safety using annotations.  E.g.
{{{
public class PersonProvider extends BeanModelProvider<Person> {
   // automatically bound to "firstName" 
   MutableValueModel<String> firstName;

   // specifies a property different from the value model name.
   @Path("surname")
   MutableValueModel<String> lastName;
}
}}} 

If this is the case then the following would be possible.
{{{
// use in a FormModel
fieldOfType(String.class).boundTo(personProvider.firstName);
// or directly bound
binder.bind(personProvider.firstName).to(someField);
}}}


= Plugins =
==!SelectionPlugin== 
Bring focus/blur and field selection into the presentation layer.  `selectionModel.addSelectionHandler(...)`, `selectionModel.select(firstName)`.  A typical use case would be focussing a field with validation errors.  I would imagine something like `selectionModel.select(validationManager.getFirstFieldWithErrors())`.  There are issues to consider here with multi-field widgets etc but by using nested form models I think we can get around most cases.

==!ValidationPlugin enhancements== 
Proper async validation support, see DesignAsynchronousValidation.

Would also nice to support validation triggers like ON_BLUR, ON_EDIT etc.  See https://wave.google.com/wave/?nouacheck&pli=1#restored:wave:googlewave.com!w%252BvIXX8JY-A

==!UndoPlugin==
Wouldn't be too hard to implement at least basic undo/redo support.  Could also work with the selection model if required.

=Would Like to but...=
== Native !UiBinder support==
Still not sure if this is possible, but here's what we'd like to be able to do: https://wave.google.com/wave/waveref/googlewave.com/w+CE2z1X_0A


==Integration with Drag&Drop layout tools==
And in my dreams... it would be to drag value models onto widgets and have the bind(model.name).to(firstName) automagically done.  I'd get to use visual layout tool (where it makes sense) and keep my OO models...