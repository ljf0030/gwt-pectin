#summary A place to collect future features and design ideas.
#labels Featured

= Future features and design ideas =

Things that would be nice:

= Pectin Core =
==Field bindings==
It would be nice to support !ValueModelProviders that have type aware keys.  That way I can use something like `FieldModel<String> name = fieldBoundTo(provider, key)`.  The `fieldOfType(String.class).boundTo/create` syntax would still remain for existing use cases. 

==Widget Bindings==
Would probably nice to add value interceptors to the bindings.  This would be a more formalised way for watermarks to change the displayed value under certain conditions. 

==Formatted fields==
Currently formatted fields don't get a chance to re-format the value the user entered with out using a deferred command (since the binding ignores model changes during the update).  The formatted field could probably handle this internally by checking the text version with a freshly formatted version and doing the deferred command thing itself, but I'd rather not use a deferred command at all if possible.   


= Plugins =
==!SelectionPlugin== 
Bring focus/blur and field selection into the presentation layer.  `selectionModel.addSelectionHandler(...)`, `selectionModel.select(firstName)`.  A typical use case would be focussing a field with validation errors.  I would imagine something like `selectionModel.select(validationManager.getFirstFieldWithErrors())`.  There are issues to consider here with multi-field widgets etc but by using nested form models I think we can get around most cases.

==!ValidationPlugin enhancements== 
Proper async validation support, see DesignAsynchronousValidation.

Would also nice to support validation triggers like ON_BLUR, ON_EDIT etc.

==!UndoPlugin==
Wouldn't be too hard to implement at least basic undo/redo support.  Could also work with the selection model if required.

=!UiCommand/!ViewCallbacks=
I've ditched this idea in favour of Activies.

=Activities=
In reading about other async efforts using activites I thought I'd try something similar.  I'm trialing an `Activity` that acts like a data pipe that contains 2 downstream channels (for the result and error) and an optional upstream channel for parameters.  I'm currently have two subtypes `ExecutableActivity` (no parameters that implements `Command`) and a `ParameterisedActivity` that can be curried into and `ExecutableActivity` when given a `Source<T>`.

By using Activities the activity behaviour can be created out side the presentation layer and passed into it.  The various parts of the presentation layer can use what ever bits they like.  Activities can send results directly to fields (`activity.resultChannel().sendTo(someField)`), views can bind activities to buttons (`buttonBinder.bind(executableActivity).to(button).andDisabledWhileActive()`) or show messages when the result comes back or if an error occurs (`activity.errorChannel().sendTo(someErrorDisplay)`) where `someErrorDisplay` implements `Sink<T>`.  I should also be able transform the channels so you can convert results or errors to messages.

An example of an `ParameterisedActivity` that saves a customer using an RPC service would be:

{{{
/**
 * This activity implementation just performs a simple save on an async service. 
 */
public class SaveCustomerActivity extends AbstractParameterisedActivity<Customer, Void, Throwable>
{
   private CustomerServiceAsync customerService;

   public GenerateAccessKeyActivity(CustomerServiceAsync customerService)
   {
      this.customerService = customerService;
   }

   @Override
   protected void performActivity(Source<Customer> source, final Channel<Void> resultChannel, final Channel<Throwable> errorChannel)
   {
      customerService.save(source.get(), new AsyncCallback<Void>()
      {
         public void onSuccess(Void result)
         {
            resultChannel.send(result);
         }

         public void onFailure(Throwable caught)
         {
            // could perform some exception handling/conversion here if 
            // we wanted to.
            errorChannel.send(caught);
         }
      });
   }
}
}}}

This would be created in the !SupervisingController (or where ever appropriate) and passed into the view (or model) as required.

So we'll make our `CustomerFormModel` implement `Source<Customer>` and in our view we'll put the following code.

{{{
public class CustomerForm extends Composite
{
   interface Binder extends UiBinder<Widget, CustomerForm>{}
   private static final Binder binder = GWT.create(Binder.class);
   
   // executable activities implement Command and can be bound to buttons
   // in the UI.
   private  ExecutableActivity<Void, Throwable> saveActivity;
   // and our model
   private CustomerFormModel model = new CustomerFormModel();

   // for binding activites to buttons and what not...
   private ButtonBinder buttons = new ButtonBinder();
   private MetadataBinder metadata = new MetadataBinder();

   @UiField Button saveButton;
   @UiField Image spinnySaveIcon;

   public CustomerForm(ParameterisedActivity<Customer, Void, Throwable> rawSaveActivity)
   {
      initWidget(binder.createAndBindUi(this));

      // Curry the parameterised activity into a Executable activity using the 
      // customer stored in the model.  We'll also add an intercepter to
      // stop the activity if the form isn't valid.  This could be put in the model
      // too if that made sense.  
      saveActivity = rawSaveActivity.curry(model).intercept(new Interceptor()
      {
         public void intercept(CallChain chain)
         {
            if (model.validate())
            {  
               // commit our changes so our currying gets updated version
               model.commit();
               // and proceed with the activity.
               chain.proceed();
            }           
         }
      });

      // now add some error display that implements Sink<Throwable> (the sink
      // has the single method `public void sink(T value)`.
      saveActivity.errorChannel().sendTo(myErrorWidget);

      // now lets wire it up to our button
      buttons.bind(saveActivity).to(saveButton).andDisableWhileActive();

      // We can also use the activities `active` value model to do other things.
      metadata.show(spinnySaveIcon).when(saveActivity.isActive());
   }
}
}}}

Interceptors can be chained through other async operations.  If we needed to prompt before performing some async operation we'd pass the proceed `Command` along to be invoked as a callback.
{{{
changeAccessCodeActivity.intercept(new Interceptor()
{
   public void intercept(CallChain chain)
   {
      // ask our view to ask a question.
      messageDisplay.ask("Do you really wish to generate a new access code?",
                         "Changing the access code will prevent access using the old code.",
                         "These changes will take effect after you save your changes.")
         .onChoosingDestructiveOption("Yes change the access code").thenExecute(chain.proceedCommand())
         .onChoosingDefault(Option.CANCEL_OPTION).justClose()
         .show();
   }
}
}}}    

This is all in it's early stages and I haven't added any HandlerRegistrations at this point.  I'm thinking about subscribing to the Activity in order to access the channels.  Perhaps something like:
{{{
ActivitySubscription saveEvents = saveActivity.subscribe();
saveEvents.resultChannel().sendTo(someSink);

// I might also add convenience methods like
saveEvents.setResultTo(someResultSink);
saveEvents.setErrorTo(someErrorSink);

// some time later if requried.
saveEvents.unsubscribe();
}}}

It's conceivable that activities may have more than two channels, something like an async operation that generates partial results like progress updates, or pushing data down as it arrives. 


=Would Like to but...=
== Native !UiBinder support==
Not even sure if it's possible yet.

==Integration with Drag&Drop layout tools==
And in my dreams... it would be to drag value models onto widgets and have the bind(model.name).to(firstName) automagically done.  I'd get to use visual layout tool (where it makes sense) and keep my OO models...