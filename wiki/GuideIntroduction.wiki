#summary Introduction to Pectin
#sidebar TableOfContents

= Introduction =

=The nice thing about !ValueModels, !ListModels and Commands and things=
One of the really nice things about using !ValueModels and !ListModels is that you can define all kinds of observable state using these simple interfaces without having to create getters/setters and different event/handler types all over the place. 

For example, if we had an object that had a `text` property of type `String`, instead of creating `setText`/`getText`/`addTextChangeHandler` methods and events and what not we can just define a `text()` method (or public final field) that returns a `ValueModel<String>`.

With this approach our bindings only need to work with few simple types, but those types can be use wired together in anyway you need.  It also lends itself to easy reuse of basic building blocks like functions, formats, converters and the like.

==An Example==
In this exmample we'll create a button that deletes the currently selected items (held in a `ListModel`).  The button must dynamically update as follows:
  # It must be disabled when the selection is empty
  # It must display "Delete" for single selections and "Delete All" for multiple.

So now lets implement it.  Pectins !UiCommands come with enable/disable built in so we only need to create a new model for our text that changes.

{{{
// lets define a controller that has a selection...
public interface MyController<T> {
  ListModel<T> selection();
  void removeItems(Collection<T> itemsToRemove);
}

// and a command that acts on that selection.
public class DeleteCommand extends AbstratUiCommand {

  private ListController<T> controller;
  private ListModel<T> selectedItems;
  private ValueModel<String> text;

  public DeleteCommand(MyController<T> controller) {
     this.controller = controller;
     this.selectedItems = controller.selection();

     // we'll disable when emtpy using a computed model
     disableWhen(Conditions.listOf(selectedItems).isEmtpy());

     // lets compute our text from the size of the selection using a Reduce function...
     text = Functions.computedFrom(selectedItems)
       .using(new Reduce<String, T>() {
          public String compute(List<? extends T> items) {
             return items.size() < 2 "Delete" : "Delete All"; 
          }
        });
  }
 
  public ValueModel<String> text() {
    return text;
  }

  public void doExecute() {
     // do the delete...
     controller.removeItems(selectedItems.asUnmodifiableList());
  }
}
}}}

Now that we've created our controller/command/models lets bind it to our passive view.
{{{
// the button to which we'll bind
Button deleteButton = new Button();

// the binder that will do the magic...
Binder binder = new Binder();

// bind the click and enabled state...
binder.bind(deleteCommand).to(deleteButton);
// bind the text...
binder.bind(deleteCommand.text()).toTextOf(deleteButton);

// TODO: this example could be simplified if Pectin defined various interfaces like
// `HasTextModel` etc which could be automatically queried and used by the binder.
}}}    

===Taking the example further===
This example is a little simplistic, we didn't ask the user to confirm and it's highly likely the command needs to do async things.  

Pectin commands also support interceptors so you can do things like:
{{{
deleteCommand.interceptUsing(confirmDeleteInterceptor);
}}}
 
Pectin also has an !AsyncUiCommand specifically for async operations that defines a `ValueModel<Boolean> active()` method.   It's then easy to disable our button while active by changing our disable logic to be:
{{{
disableWhen(is(active())or(listOf(selectedItems).isEmpty()));
}}}

It also wouldn't be too hard to update the above example to have the button change it's text to to "Deleting" while the delete was proceeding.

=The nice thing about !FormModels=
TODO

=Garbage collection and you=
TODO: Talk about `Binder.dispose()`, `Disposable` and `GarbageCollector`.