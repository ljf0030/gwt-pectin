#summary Introduction to Pectin
#sidebar TableOfContents

= Introduction =

Kaspar Fischer has begun working on a good introduction to the basics at http://code.google.com/p/gwt-pectin-docs/wiki/PectinAPIOverview

==The nice thing about !ValueModels, !ListModels and Commands and things==
One of the really nice things about using !ValueModels and !ListModels is that you can define all kinds of complex models using these simple interfaces without having to create getters/setters and different event/handler types all over the place. 

For example, if we had an object that had a `text` property of type String, instead of creating setText/getText/addTextChangeHandler etc methods and events and what not you can just define a `text()` method (or public final field) that returns a `ValueModel<String>`.

With this approach our bindings only need to work with few simple types, but those types can be use wired together in anyway you need.  It also lends itself to easy reuse of basic building blocks like functions, formats, converters and the like.

===An Example===
In this exmample we'll create a button that deletes the currently selected items (held in a `ListModel`).  The button must dynamically update as follows:
  # It must be disabled when the selection is empty
  # It must display "Delete" for single selections and "Delete All" for multiple.

So now lets implement it.  Pectins UiCommand come with enable/disable built in so we only need to create a new model for our text that changes.

{{{
// lets define a controller that has a selection...
public interface MyController<T> {
  ListModel<T> selection();
  void removeItems(Collection<T> itemsToRemove);
}

// and a command that acts on that selection.
DeleteCommand extends AbstratUiCommand {

  private ListController<T> controller;
  private ListModel<T> selection;
  private ValueModel<String> text;

  public DeleteCommand(MyController<T> controller) {
     this.controller = controller;
     this.selection = controller.selection();

     // we'll disable when emtpy using a computed model
     disableWhen(Conditions.listOf(selection).isEmtpy());

     // lets compute our text from the size of the selection using a Reduce function...
     text = Functions.computedFrom(selection)
       .using(new Reduce<String, T>() {
          public String compute(List<? extends T> list) {
             return list.size() < 2 "Delete" : "Delete All"; 
          }
        });
  }
 
  public ValueModel<String> text() {
    return text;
  }

  public void doExecute() {
     // do the delete...
     controller.removeItems(selection.asUnmodifiableList());
  }
}
}}}

Now that we've created our controller/command and models lets bind it to our completely passive view.
{{{
Binder binder = new Binder();
Button deleteButton = new Button();

// Now the button will execute the command when clicked and will
// disable when the selection is empty 
binder.bind(deleteCommand).to(deleteButton);

// And the button text will update when the selection contains more 
// than one item.  
binder.bind(deleteCommand.text()).toTextOf(deleteButton);

// TODO: this example could be simplified if Pectin defined various interfaces like
// `HasTextModel` etc which could be automatically queried and used by the binder.
}}}    

It wouldn't be too hard to update the above example to have the button disble and change it's text to to "Deleting" if the delete was an asyn process.

==The nice thing about !FormModels==
TODO