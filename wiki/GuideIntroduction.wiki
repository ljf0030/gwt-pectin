#summary Introduction to Pectin
#sidebar TableOfContents

= Introduction =

Kaspar Fischer has begun working on a good introduction to the basics at http://code.google.com/p/gwt-pectin-docs/wiki/PectinAPIOverview

==The nice thing about !ValueModels & !ListModels and so forth==
One of the really nice things about !ValueModels and !ListModels is that you can define all kinds of things using these simple interface without having to create getters/setters and different event/handler types all over the place. 

For example, if we had an object that had a `text` property of type String, instead of creating setText/getText/addTextChangeHandler etc methods and events and what not you can just define a `text()` method (or public final field) that returns a `ValueModel<String>`.

Using this approach our bindings only need to work with few simple types, but those types can be use together in anyway you need.  It also lends itself to easy reuse of basic building blocks like functions, formats and the like.

==An Example==
{{{
// lets define a controller that has a selection...
public interface ListController<T> {
  ListModel<T> selection();
}

// and a command that acts on that selection.
DeleteCommand extends AbstratUiCommand {

  private ListController<T> controller;
  private ValueModel<String> text;

  public DeleteCommand(ListController<T> controller) {
     this.controller = controller;

     // we'll disable when emtpy...
     disableWhen(Conditions.listOf(controller.selection()).isEmtpy());

     // lets compute our text from the size of the selection...
     text = Functions.computedFrom(controller.selection())
       .using(new Reduce<String, T>() {
          public String compute(List<? extends T> list) {
             return list.size() < 2 "Delete" : "Delete All"; 
          }
        });
  }

  public void doExecute() {
     // do the delete...
     controller.deleteSelectedItems();
  }
}

// And lets bind our contoller/commands/model to our view... 
Binder binder = new Binder();
Button deleteButton = new Button();

// the button will execute the command when clicked and will
// disable when the selection is empty 
binder.bind(deleteCommand).to(deleteButton);

// the button text will update when the selection contains more 
// than one item.  
binder.bind(deleteCommand.text()).toTextOf(deleteButton);
}}}
    
TODO: the button binding example could be improved by defining simple interfaces like `HasTextModel` etc which could be automatically queried and used by the binder.