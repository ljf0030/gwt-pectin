#summary Binding the bean properites
#sidebar TableOfContents

=Binding to Beans=

The process of binding bean properties to fields is relatively simple.  The steps are as follows:

==1. Define our Bean==

The only requirement is that our bean follows the standard Java bean getter/setter method naming convention.

{{{
public class Person {
   private String givenName;   
   private String surname;

   // define our standard the getters and setters.
   public String getGivenName() {return givenName;}
   public String setGivenName(String givenName) {this.givenName = givenName;}

   public String getSurname {return surname;}
   public String setSurame(String surname) {this.surname = surname;}
}
}}}


==2. Create a `BeanModelProvider<T>` for our bean==

The `BeanModelProvider<T>` acts as a `ValueModel` factory for our bean.  To use it we define an abstract subclass for our bean and instantiate it using `GWT.create()`

{{{
// define our abstract sub class for our bean type.
public abstract class PersonProvider extends BeanModelProvider<Person>{};

// and let GWT create an instance for us.
PersonProvider personProvider = GWT.create(PersonProvider.class);
}}}


==3. Use the provider in our `FormModel`==

Now we can use the provider when creating our field models.  The builder methods support binding to the providers. 

{{{
public class PersonFormModel extends FormModel {

   protected final FieldModel<String> givenName;
   protected final FieldModel<String> surname;

   public PersonFormModel(PersonProvider personProvider) {
      
      // bind to our "givenName" property.
      givenName = fieldOfType(String.class).boundTo(personProvider, "givenName");

      // bind to our "surname" property.      
      surname = fieldOfType(String.class).boundTo(personProvider, "surname");
   }
}
}}}


==4. Set the bean on the provider==

Once all the wiring has been done all that is left is to configure the provider with the bean we wish to display or edit.

{{{
// configure the providers bean.  All the fields bound to the provider will 
// automatically update. 
personProvider.setBean(new Person());
}}}

==5. Committing changes==
By default changes are not automatically propegated back to the bean.  To update the bean you need to call `commit()` on the provider.

{{{
// write the change back to the underlying bean.
personProvider.commit();
}}}

You can also call revert 
{{{
// revert all models back to the bean state.
personProvider.revert();
}}}


=== The Other Provider Types ===
There are two additional provider types, `AutoCommitBeanModelProvider` and `CopyingBeanModelProvider`.  

The `AutoCommitBeanModelProvider` writes all changes to the underlying bean as they happen. 

The `CopyingBeanModelProvider` copies values to and from beans without maintaining a refernce to any particular bean.  It also supports the ability to write changes without clearing the dirty state of the provider.  This allows you to write changes to a bean, initiate an RPC call and only clear the dirty state when the RPC call was succeeds.

=Binding to collection properties=

Pectin also allows you to bind collection properties to `ListModel`s.  In this case the bean must define getters and setters for the collection properties.  Please note Pectin doesn't support indexed Java bean properties.

Lets add a simple collection to our `Person` model.  We use copy on read and write to ensure any modifications are made on copies.

{{{
public class Person {
   private String givenName;   
   private String surname;

   // our collection property
   private List<Wine> favoriteWines = new ArrayList<Wine>();

   // getters and setters for our collection.  We copy on read and write to 
   // prevent the collection being changed underneath us. 
   public List<Wine> getFavoriteWines {return new ArrayList(favoriteWines);}
   public void setFavoriteWines(List<Wine> surname) {this.favoriteWines = new ArrayList(favoriteWines);}
}
}}}

Now we can bind `ListModel` fields to our collection property.  Pectin supports the basic java collection interfaces out of the box.

{{{
public class PersonFormModel extends FormModel {

   protected final FieldModel<String> givenName;
   protected final FieldModel<String> surname;

   protected final ListFieldModel<Wine> favoriteWines;

   public PersonFormModel(PersonProvider personProvider) {
      
      // bind our regular models.
      ...

      // bind our collection to a list model.
      favoriteWines = listOfType(Wine.class).boundTo(personProvider, "favoriteWines");
   }
}
}}}

==Handling alternate collection types==
If you need to bind to a collection type other than the standard `Collection`, `List`, `Set` or `SortedSet` you can add a `CollectionConverter` to the `BeanModelProvider`.

The following converter can be used for bean properties whose type is `HashSet`.

{{{
CollectionConverter converter = new CollectionConverter<HashSet>() {

   public Collection<?> fromBean(HashSet<?> source)
   {
      return source;
   }

   public HashSet toBean(List<?> source)
   {
      return new HashSet<Object>(source);
   }
}

// now register the converter
personProvider.registerCollectionConverter(HashSet.class, converter);
}}}

= Dirty Tracking =
The !BeanModelProvider also provides a `ValueModel<Boolean>` that tracks the dirty state of the data.  If any value is changed from the state defined by the bean then the value model will change to `true`.  If the change is reverted (either by calling revert or by a user change) the dirty state will change back to `false`.  Likewise committing the changes will also revert the dirty state back to `false`. 

{{{
ValueModel<Boolean> dirty = personProvider.getDirtyModel();
}}}

If you have more than one provider you can use conditions to create a global dirty model.

{{{
ValueModel<Boolean> dirty = Conditions.or(personProvider.getDirtyModel(), addressProvider.getDirtyModel());
}}}


Then the dirty model can be easily used to enabled and disable buttons in the view.

{{{
MetadataBinder metadata = new MetadataBinder();

metadata.bindValueOf(model.dirty).toEnablednessOf(saveButton);
}}}


=Binding to nested beans=

There are often times where you need to bind to properties of nested classes, in this case you can chain property providers together.  Lets take an example where we add an `Address` property to the `Person` defined earlier.

{{{
public class Person 
{
   // other properties...
   ...

   // our new address property
   private Address address;
   // and it's accessors
   public void setAddress(Address address) {this.address = address;}
   public Address getAddress() {return address;}
}

public class Address
{
   private String addressLineOne;
   private String addressLineTwo;
   private String city;
   private String state;
   private PostCode postCode;
  
   public String setAddressLineOne(String text) {addressLineOne = text;}
   public String getAddressLineOne() {return addressLineOne;}
   public String setAddressLineTwo(String text) {addressLineTwo = text;}
   public String getAddressLineTwo() {return addressLineTwo;}
   ....etc
}
}}} 

Now we create our providers as before, this time including a provider for the `Address` class.

{{{
public abstract class PersonProvider extends BeanModelProvider<Person>{};
public abstract class AddressProvider extends BeanModelProvider<Address>{};


PersonProvider personProvider = GWT.create(PersonProvider.class);
AddressProvider addressProvider = GWT.create(AddressProvider.class);
}}}

And now we set the address provider to use the "address" value model.

{{{
// get the address value model from the person provider.
MutableValueModel<Address> addressValueModel = personProvider.getValueModel("address", Address.class);

// and set it as the source for the address provider.
addressProvider.setBeanSource(addressValueModel);
}}}

From here on, anytime you call `personProvider.setBean(aPersonInstance)` the address provider will automatically update.

Please note that you will need to call commit on both providers to apply any changes.

{{{
// we have to commit on both providers
addressProvider.commit();
personProvider.commit();
}}}

== OGNL/EL style binding language ==
Idealy I'd like to be able to use an OGNL/EL style binding language, but this is outside the scope of this project (and my experience) for now.  Any contributions welcome. 