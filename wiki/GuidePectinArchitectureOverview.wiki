#summary Architectural overview of Pectin
#labels Featured
#sidebar TableOfContents

=Overview of the Pectin approach=
Pectin's approach is to segregate UI code into three basic facets or 'zones of responsibility' if you like, the domain, the presentation model and the View.  The following illustrates.  One of the advantages of this approach is that it brings consistency to developing views.  Behaviour and state is defined by the Presentation Model and the View remains passive.  

The following illustrates the chain of data as it passes from the domain to the view. 

{{{
[Domain Data/Services] <-[Adapters]-> [Presentation Model] <-[Bindings]-> [View]
                                               |
                                           [Plugins]
}}} 

*Please note:* The above diagram demonstrates the data path and relationships between the various components of pectin.  It doesn't imply an architectural pattern or an approach to implementing your app or form.  Typically I embed presentation models inside views, those views implement some kind of `Editor` or `Display` interface which then interacts with a supervising controller of some kind.  The view typically delegates most of the `Display` interface to the presentation model.   

The following outlines the roles of the various bits and pieces.
  # *Domain Data* - data like the fields of a Customer, Address etc.
  # *Domain Services* - the things that are used to load/save the domain data and do other server side things.  Pectin doesn't use these currently but I'm hoping I can for async validation.
  # *Adapters* - The Adapters are responsible for creating `ValueModel`'s from your domain data.  Pectin currently provides `BeanModelProvider`, `AutoCommitBeanModelProvider` and `CopyBeanModelProvider`.  These adapters can either buffer changes (and track dirty state) or pass them directly through.  By using an adaption layer pectin can use data from practically any source.  If !ValueModels created by adapter implement auxiliary interfaces these can also be utilised by plugins.
  # *Presentation Model* - This is your `FormModel`.  It holds the data, event handlers and other things required by the view. 
    * View data includes includes such things as enabled, visible, validation information and anything else you view requires that isn't provided by your domain model.  This additional state is typically managed by plugins or simple value models that hold custom state (e.g. `ValueModel<Boolean> showMoreDetail = ....`)
    * The Presentation Model also typically contains items such as actions/commands (or just plain click handlers) that operate within the scope of the view (e.g. a cancel button, a show/hide button).  This keeps the behaviour out of the view (i.e. no `@UiHandlers`) and you end up with view code like `button.addClickHandler(model.cancelHandler)`.
  # *Bindings* - These are created by pectin using `WidgetBinder.bind(model.field).to(widget)` style code in your view.  Plugins also generate bindings but this is typically automated during the widget binding process.  Most plugins will also support additional binding helpers like `MetadataBinder.bindValueOf(model.showMoreDetail).toVisibilityOf(detailsPanel)`. If the bindings don't meet your requirements you can always hook directly into the !ValueChangeEvents generated by the values in the presentation model.  
  # *View* - responsible for binding widgets to the presentation model, laying things out and managing things like tab orders and what not.  It may well implement your 'Display' interface but will ideally delegate most of this to the model (but this all depends on your approach to your applications infrastructure).


=Understanding !ValueModels=
Within the Presentation Model pectin makes extensive use of !ValueModels.  A value model abstracts the notion of a value (e.g. things like a firstName, postcode or account ballance) by providing access and mutation methods (get/set) and notifications when the value is modified.  Thus all interested parties can modify the value, and all will recieve updates when it is modified by others.  This is what allows pectin to use a declarative style api. 

!ValueModels come in two basic types, `ValueModel` and `MutableValueModel`.  In the future I may implement an `OccassionllyMutableValueModel` (with a better name of course) for values that can change mutability over time (like values bound via a property path to an underlying object graph).

Please note that while `ValueModel` doesn't provide mutation methods it can still change.  An example would be a value computed using a `Reduce` style function (e.g. such as suming function).  In this case setting the value is meaningless but the value will change if any of the source values update. 

==!FieldModels are just !ValueModels==
!FieldModels are a !ValueModel that hold a reference back to the form that created it.  This hook allows plugins to work as they do.  The !WidgetBinder uses this to notify the form that a binding has been created, the form then notifies the plugins and they perform additional widget configuration as required.  
{{{
// create our field model 
FieldModel<String> firstName = fieldOfType(String.class).boundTo(beanProvider, "firstName");

// MetadataPlugin.enable(FieldModel<T>) now sets up metadata models in the 
// form and get's ready for callbacks from the binding process. 
enable(firstName).when(...);
}}}

{{{ 
WidgetBinder binder = ...;
TextBox firstName = ...;
// The binder notifies the form which notfies the metadata
// plugin which binds the enabled state to the textbox
binder.bind(model.firstName).to(firstName);
}}} 

==!ListModels and !ListFieldModels==
!ListModel and !ListFieldModel are the !ValueModel and !FieldModel equivalents for lists.  They fire change events and the mutable versions support add/remove & set operations.  

=When all you have is a hammer...=
The important thing to remember when using Pectin (or any library) is that the library (or pattern) should serve the problem your trying to solve and not the other way around.  i.e. in the case of pectin, don't try and make everything a value model.  Think of your presentation model as "the stuff my view needs to function" and if pectin doesn't provide what you need then add something else (or use another library or pattern).

An example of "not everything is a value model" would be exposing a `SuggestOracle` to your view.  Another would be using a nested presentation model to facilitate reuse of complex components (i.e. such as a validated address editor component).  This would allow you to synchronise and customise validation between the parent form and the editor component all at the presentation model level.

It's also important to remeber that pectin *is not an application infrastructure design pattern*.  It's strictly concerned with modeling views (and a specific class of views at that).  While it can have hooks into domain data and services, this is really something specific for each application and it's rarely a case of one size fits all.  

As an example I wouldn't use pectin as the basis for implementing master detail style interface.  I would use it to create the detail portion of the view (if it solved the problem of course) but the master view would hopefully use tools specific to displaying data in lists and/or tables.  A supervising controller or some other facade style mediator would then mediate between the two (depending of course on the design requirements).


  