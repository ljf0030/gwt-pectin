#summary Architectural overview of Pectin
#sidebar TableOfContents

=Overview of the Pectin approach=
Pectin's approach is to segregate UI code into three basic facets or 'zones of responsibility' if you like, the domain, the presentation model and the View.  The following illustrates.  One of the advantages of this approach is that it brings consistency to developing views.  Behaviour and state is defined by the Presentation Model and the View remains passive.  

The following illustrates the chain of data as it passes from the domain to the view. 

{{{
[Domain Data/Services] <-[Adapters]-> [Presentation Model] <-[Bindings]-> [View]
                                               |
                                           [Plugins]
}}} 

*Please note:* The above diagram demonstrates the data path and relationships between the various components of pectin.  It doesn't imply an architectural pattern or an approach to implementing your app.  Typically I embed presentation models inside views, those views implement some kind of Editor or Display which then interacts with a Supervising controllers of somekind.  The view typically delegates to the presentation model as required. 

The following outlines the roles of the various bits and pieces.
  # *Domain Data* - data like the fields of a Customer, Address etc.  Domain should have no view state or dependency on view code what so ever (although binding may require annotations).
  # *Domain Services* - the things that are used to load/save the domain data and do other server side things.  Pectin doesn't use these currently but I'm hoping I can for async validation.
  # *Adapters* - The Adapters are responsible for creating `ValueModel`'s from your domain data.  Pectin currently provides `BeanModelProvider`, `AutoCommitBeanModelProvider` and `CopyBeanModelProvider`.  These adapters can either buffer changes (and track dirty state) or pass them directly through.  By using an adaption layer pectin can use data from practically any source.
  # *Presentation Model* - This is your `FormModel`.  It holds the data and actions required by the view. 
    * View data includes includes such things as enabled, visible, validation information and anything else you view requires that isn't provided by your domain model.  This additional state is typically managed by plugins or simple value models that hold custom state.
    * The Presentation Model also typically contains items such as actions/commands (or just plain click handlers) that operate within the scope of the view (e.g. a cancel button, a show/hide button).  This keeps the behaviour out of the view (i.e. no `@UiHandlers`) and you end up with view code like `button.addClickHandler(model.cancelHandler)`.
  # *Bindings* - These are created by pectin using `WidgetBinder.bind(model.field).to(widget)` style code in your view.  If the bindings don't meet your requirements you can always hook directly into the !ValueChangeEvents generated by the values in the presentation model.  
  # *View* - responsible for binding widgets to the presentation model, laying things out and managing things like tab orders and what not.  It may well implement your 'Display' interface but will ideally delegate most of this to the model (but this all depends on your approach to your applications infrastructure).


=Understanding !ValueModels=
Within the Presentation Model pectin makes extensive use of !ValueModels.  A value model abstracts the notion of a value (e.g. things like a firstName, postcode or account ballance) by providing access and mutation methods (get/set) and notifications when the value is modified.  Thus all interested parties can modify the value, and all will recieve updates when it is modified by others.  This is what allows pectin to use a declarative style api. 

!ValueModels come in two basic types, `ValueModel` and `MutableValueModel`.  In the future I may implement an `OccassionllyMutableValueModel` (with a better name of course) for values that can change mutability over time (like values bound via a property path to an underlying object graph).

Please note that while `ValueModel` doesn't provide mutation methods it can still change.  An example would be a value computed using a `Reduce` style function (e.g. such as suming function).  In this case setting the value is meaningless but the value will change if any of the source values update. 

=When all you have is a hammer...=
The important thing to remember when using Pectin (or any library) is that the library (or pattern) should serve the problem your trying to solve and not the other way around.  i.e. in the case of pectin, don't try and make everything a value model.  Think of your presentation model as "the stuff my view needs to function" and if pectin doesn't provide what you need then add something else (or use another library or pattern).

It's also important to note that pectin *is not an application infrastructure design pattern*.  It's strictly concerned with modeling the view layer.  While it can have hooks into domain data and services, this is really something specific for each application and it's rarely a case of one size fits all.  

As an example I wouldn't use pectin as the pattern to implement a master detail style view.  I would use it to create the detail portion of the view (if it solved the problem of course) but the master view would hopefully use tools specific to displaying data in lists and/or tables.  A supervising controller would then mediate between the two (depending of course on the design requirements).

An example "not everything is a value model" would be using a nested presentation model to facilitate reuse of complex components (i.e. such as a validated address editor component).  This would allow you to synchronise and customise validation between the parent form and the editor component all at the presentation model level.

  