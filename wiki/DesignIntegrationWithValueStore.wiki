#summary Design thoughts for interacting with ValueStore
#labels Featured

=Initial thoughts on integration with !ValueStore=

Integration with [http://code.google.com/p/google-web-toolkit/wiki/ValueStoreAndRequestFactory Googles ValueStore proposal] would give pectin CRUD and JSR-303 support out of the box.

From the initial design proposal it looks like I should be to build an adaption layer for !ValueStores that can act as a drop in replacement for pectins !BeanModelProviders:

{{{
[ValueStore] <-[ValueStoreAdapter]-> [Presentation Model] <-[Bindings]-> [View]
                                             |
                                     [Validation Plugin]
}}}

(See GuidePectinArchitectureOverview for more detail on the parts above)

From the code examples given I'm hoping pectin will be able to use the canonical ValueStore.  If so I should be able to provide native integration in the form model. 

{{{
// and use it to generate our fields.
FieldModel<String> name = fieldBoundTo(valueStore, TroopId.name());
FieldModel<String> serialNumber = fieldBoundTo(valueStore, TroopId.serialNumber());
}}}

This concise syntax (i.e. `fieldBoundTo(...)` instead of `fieldOfType(Class<T>).boundTo(..)` will only be possible if the `Property` returned by `TroopId.name()` has a method such as `Class getValueType()` in addition to the generic declaration.  Some plugins need this information during binding.  i.e. pectin needs to be able to do this:
{{{
Property<TroopId, String> name = TroopId.name();
// i.e. this would return String.class for plugins to make runtime checks.
Class nameClass = property.getValueType()
}}}

If this isn't supported then I'll have to revert to the existing `fieldOfType(String.class).boundTo(valueStore, TroopId.name())` semantics.


== Tracking Dirty State ==
The design proposal include a `store.isChanged()` method but it's unclear if this state is observable.  This is not a big issue with pectin as dirty state is always provided by the adaption layer anyway, if it's not supported there then it's not supported.

=Async Validation=

*See* DesignAsynchronousValidation for changes to the !ValidationPlugin so support async validators outside of !ValueStores

Hopefully I'll be able to create a `ValueStoreValueModel` that exposes the validation capabilities of the store.  From here the validation plugin could query the fields underlying source model and auto-wire the validation hooks.  Pectin already supports the notion of external validation messages so it shouldn't be hard to hook these up the value store.  E.g. 

{{{
// the validation plugin would query the underlying value model
// and automatically install the appropriate validation hooks.
validateField(name).usingValueStore();
}}}

At this stage I'm not sure if ValueStore supports field level validation.  Pectin could probably work around this to provide field level validation from the store if it came to that but I'd rather not.

It may be worth making this a little less bound to `ValueStore` and have our `ValueStoreValueModel` implement interfaces like `HasValidationService`,  `HasValidators`,  `HasAsynValidators` or even some thing like just `HasValidationErrors`.  That way if you want to use something else other than `ValueStore` you can write your own adapter and still use all of pectins functionality.  In this case I'd probably name the validation method something like `validateField(name).usingDomainValidationServices()` or something. 

There may be a requirement to hook a callback up to transform any async errors in to meaningful error messages in the case of an RPC failure.  The mechanism for displaying such errors is likely to be highly application specific. 

There's the possibility it could be auto wired (if the above is solved), but I'm not a fan of this as it hides the fact from the next guy who comes along.  I don't mind magic, but I'm less fond of vast quantities of invisible magic. 