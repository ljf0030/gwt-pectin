#summary Guide to Activities
#sidebar TableOfContents

= Activities (Experimental) =

Activities are an experimental addition to pectin to model "things that do stuff" in a similar fashion to Swing's `Action` class.  There are two basic types of Activities - a basic synchronous version (`Activity`) and an async version (`TemporalActivity`) of which there are two types (`AsyncActivity` and `AbstractIncrementalActivity`).  All activities implement `Command` and provide an `enabled` model.  The async activities also provide an `active` model that's `true` while the activity is in progress.

Checkout the Activities & Buttons tab [http://scratchpad.pietschy.com/pectin/PectinDemo.html on the demo].  You can read [http://code.google.com/p/gwt-pectin/source/browse/trunk/demo/src/main/java/com/pietschy/gwt/pectin/demo/client/activity/ the source code] for more info.

= Concepts =
One of the difficulties in developing a activity/command style infrastructure is that the effects of operations can be wide spread.  The commands often interact with the model both before and after the operation, their errors need to be displayed in the view and the view probably needs to display indication that the activity is in progress.  Supervising controllers may need to know when an activity is complete or has failed. 

To manage these issues Activities have a number of concepts:
  * *Activity* - the base type for all activities.  It extends `Command` and provides an `enabled()` method that returns a `ValueModel<Boolean>` representing the enabled state of the activity.
  * *!TemporalActivity* - (is there a better name??) an interface that exends `Activity` for activities that execute asynchronously, i.e. execute returns before the activity is completed.  `TemporalActivities` also provide and `active()` method that returns a `ValueModel<Boolean>` representing the active state of the activity.  The two main implementations are `AbstractIncrementalActivity` and `AsyncActivity`.   
  * *!AsyncActivity`<R,E>`* - a `TemporalActivity` activity that performs some async operation and then publishes the results (either successes of type R or errors of type E).  Activities can publish errors of any type so can be used to transform Throwables into a specific error type or message or message key.  Implementations typically extend `AbstractAsyncActivity`.
  * *Channel`<T>`* - `Channels` are a basic event mechanism that allow simple connection of event produces to consumers.  `AsyncActivities` have a result channel and an error channel. 
  * *!AsyncEvents`<R,E>`* - `AsyncActivites` provide event hooks so you can perform actions on start, end and error or send the results or errors to various locations.  There are two variants, `always()` and `onNextCall()` events.  e.g. `save.always().sendResultTo(someDestination)` or  `save.onNextCall().invokeOnSuccess(invocation.getProceedCommand())`.   Behind the scenes this just subscribes to the appropriate channel.
  * *Interceptors* - Activities allow the view to create intercepted instances of the activity.  This allows the view to interact with the user prior to the activity starting.  The intercption is callback based so supports asynchronous operation (i.e. prompting via a dialog or other means).
  * *!WidgetBinder* - Allows the view to bind Activities to buttons (`binder.bind(saveActivity).to(saveButton)` and various widgets (`HasValue`, `HasText`, `HasHTML` and others) to Channels.  Since activities have an active state you can easily show and hide things while they're running e.g. `binder.show(saveMessage).when(saveActivity.active())`. 
  
= Interceptors =
`AsyncActivities` allow you to add interceptors that get invoked prior to the command executing.  Currently these are only on `AbstractAsyncActivity` but will hopefully be added to the others soonish. 

{{{
// We can add interceptors in the view to prompt the user.  Thhe intercept
// method returns a new instance the we then use to bind to buttons.
deleteCustomerActivity.beforeStartingRun(new Interceptor()
{
   public void intercept(Invocation invocation)
   {
      // ask our view to ask a question.
      dialog.ask("Do you really want to delete this customer?",
                 "This change can't be undone.")
         .onChoosingDestructiveOption("Yes delete the customer").thenExecute(invocation.getProceedCommand())
         .onChoosingDefault("Cancel").justClose()
         .show();
   }
});

// clicking the button will prompt the user.
binder.bind(deleteCustomerActivity).to(deleteCustomerButton);

// and show a message while the activity is in progress.
binder.show(deletingMessage).when(deleteCustomerActivity.isActive());

// once it completes we can display errors
binder.sendErrorsOf(deleteCustomerActivity).to(myErrorDisplay);
}}}

= !DelegatingActivity =
`DelegatingActivity` is an activity that delegates it's behaviour and state to another activity.  This is useful when you need one activity to have different behaviours based on a changing context within the UI.  In such cases you just set the delegate that's relevant at the time.  The delegate will automatically track the enabled and active state of it's delegate.  Setting the delegate to null will remove all handlers from the delegate (so you won't get lingering references).

Another use of delegating activities is to add additional constraints to the activities enabled state.  As an example I have an `PublishActivity` that operates directly on a model but I need the associated button to be disabled while an `IncrementalActivity` builds the view.  The following shows how to do this without out the publish activity having any knowledge of how the view is built. 

{{{
// An IncrementalActivity that builds the view.
BuildUiActivity buildUiActivity = new BuildUiActivity();

// Create our delegate.  We'll disable it while we're building
// the view.
DelegatingActivity delegatingPublish = new DelegatingActivity();
delegatingPublish.disableWhen(buildUiActivity.active());
delegatingPublish.setDelegate(realPublishActivity);

// now our publish button will only be enabled when the realPublishActivity
// is enabled and the buildUiActivity is not active. 
widgetBinder.bind(delegatingPublish).to(publishButton);
}}}
