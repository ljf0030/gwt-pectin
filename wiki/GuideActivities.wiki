#summary Guide to Activities

= Activities (Experimental) =

Activities are an experimental addition to pectin to model "things that happen" in a similar fashion to Swing's `Action` class.  Activities implement `Command` and provide states for enabled and active (`ValueModel<Boolean>`'s).  They also provide support for interception so view's can confirm actions in an asynchronous manner.

Checkout the Activities & Buttons tab [http://scratchpad.pietschy.com/pectin/PectinDemo.html on the demo].  The demo has links to the source code. 

*Please Note:* The source code contains both `AsyncActivity` and `Activity`.  `AsyncActivity` is what this document refers to.  While `Activity` exists and is in use it's had little development or focus.

= Concepts =
One of the difficulties in developing a activity/command style infrastructure is that the effects of operations can be wide spread.  The commands often interact with the model both before and after the operation, their errors need to be displayed in the view and the view probably needs to display indication that the activity is in progress.  Supervising controllers may need to know when an activity is complete or has failed. 

To manage these issues Activities have a number of concepts:
  * *!AsyncActivity`<R,E>`* - an async activity that performs some async operation and then publishes the results (either successes of type R or errors of type E).  Activities can publish errors of any type so can be used to transform Throwables into a specific error type or message or message key.  Implementations typically extend `AbstractAsyncActivity`.
  * *Channel`<T>`* - Activities have a result channel and an error channel.  Once the execution is complete the results will be published on the appropriate channel.  Various aspects of the presentation layer can subscribe to the channels as required.
  * *Callbacks* - Activities also provide convenience methods for executing additional operations when an activity completes or fails.  i.e. `save.onSuccessExecute(someOtherCommand)`.   Behind the scenes this just subscribes to the appropriate channel.
  * *Interceptors* - Activities allow the view to create intercepted instances of the activity.  This allows the view to interact with the user prior to the activity starting.  The intercption is callback based so supports asynchronous operation (i.e. prompting via a dialog or other means).
  * *!ActivityBinder* - Allows the view to bind Activities to buttons and various widgets (`HasValue`, `HasText`, `HasHTML` and others) to Channels.  Since activities have an active state you can easily show and hide things while they're running e.g. `metadataBinder.show(saveMessage).when(saveActivity.isActive())`. 
  
= Interceptors =
Interceptors are implemented but have only been lightly trialed.  The following demonstrates the intent of the interceptor.

{{{
// We can add interceptors in the view to prompt the user.  Thhe intercept
// method returns a new instance the we then use to bind to buttons.
deleteCustomerActivity = deleteCustomerActivity.intercept(new Interceptor()
{
   public void intercept(Invocation invocation)
   {
      // ask our view to ask a question.
      dialog.ask("Do you really want to delete this customer?",
                 "This change can't be undon.")
         .onChoosingDestructiveOption("Yes delete the customer").thenExecute(invocation.getProceedCommand())
         .onChoosingDefault(Option.CANCEL_OPTION).justClose()
         .show();
   }
});

// clicking the button will prompt the user.
activityBinder.bind(deleteCustomerActivity).to(deleteCustomerButton);
// and show a message while the activity is in progress.
metadataBinder.show(deletingMessage).when(deleteCustomerActivity.isActive());

// once it completes we can diplay errors
activityBinder.sendErrorsOf(deleteCustomerActivity).to(myErrorDisplay);
}}}