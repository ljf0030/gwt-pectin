#summary An example of using Pectin with MVP

= Using Pectin with MVP =

This page  to integration of Pectin with the [http://code.google.com/webtoolkit/doc/latest/tutorial/mvp-architecture.html MVP sample] in the GWT documentation.  The example itself as a lousy test case for Pectin however since the customer edit form is so trivial.  But for the sake of the argument I'll do it anyway and add a few features to give a better feel for the features of Pectin.

= The Approach =
There are a couple of ways to approach the design.  In this case I've chosen to embed the presentation model within the view.  You could also have the Presenter own the Presentation Model but in this case there were no clear advantages to that approach and it only increased the complexity of the Presenter.

= Updating the !EditContactPresenter =
The changes to the presenter are minimal and main include changes to the Display interface and the pieces of code that interact with it. The changes to the Display interface are:

  # Replacing the `HasValue` getters with a single setter for the `Contact`.
  # Add new `commit()` method to write any changes to the `Contact` prior to saving.
  # Added `validate()` method to support the new validation features.

Once this has been done the `EditContactPresenter` no longer acts as mediator between the `Contact` and the fields in the view.  The Display interface now becomes.

{{{

public interface Display {

   HasClickHandlers getSaveButton();

   HasClickHandlers getCancelButton();
      
   // replace all the HasValue getters with this
   void setContact(Contact contact);

   // added new commit method to write changes to the 
   // current contact.  
   void commit();

   // new method to validate the current state of the
   // form before committing the changes.
   boolean validate();
     
   Widget asWidget();      
}
}}}

The other major changes to the `EditContactPresenter` are the Constructor and the `doSave()` method.

The Constructor call to get the contact now becomes: 
{{{
rpcService.getContact(id, new AsyncCallback<Contact>() {

   public void onSuccess(Contact result) {
      EditContactPresenter.this.contact = result;
      // no longer have to update each field, we just pass in the Contact
      // and let the views Presentation Model handle that.
      EditContactPresenter.this.display.setContact(result);
   }

   public void onFailure(Throwable caught) {
      Window.alert("Error retrieving contact");
   }
});

}}}

And the `doSave()` method now becomes:
{{{

private void doSave()
{
   // we've added validation so we only save if the form is valid
   if (display.validate()) {

      // all is good so commit the changes to the Bean
      display.commit();

      // and proceed as per normal
      rpcService.updateContact(display.getContact(), new AsyncCallback<Contact>() {

         public void onSuccess(Contact result)
         {
            eventBus.fireEvent(new ContactUpdatedEvent(result));
         }

         public void onFailure(Throwable caught)
         {
            Window.alert("Error updating contact");
         }
      });
   }
}
}}}
 

= Updating the !EditContactView = 

== Create our Presnetation Model ==
The first step was to create a Presentation Model for the view.  It defines the three fields displayed by the view.  In order to make things a little bit more realistic I've added validation and watermarks. 

{{{
public class EditContactViewModel extends FormModel
{
   // create our bindings to our bean
   public abstract static class ContactProvider extends BeanModelProvider<Contact> {}
   private ContactProvider contactProvider = GWT.create(ContactProvider.class);

   protected final FieldModel<String> firstName;
   protected final FieldModel<String> lastName;
   protected final FieldModel<String> emailAddress;

   public EditContactViewModel()
   {
      // create our fields and bind to our bean
      firstName = fieldOfType(String.class).boundTo(contactProvider, "firstName");
      lastName = fieldOfType(String.class).boundTo(contactProvider, "lastName");
      emailAddress = fieldOfType(String.class).boundTo(contactProvider, "emailAddress");

      // add some validation rules
      validateField(firstName).using(new NotEmptyValidator("Please enter your first name"));
      validateField(lastName).using(new NotEmptyValidator("Please enter your last name"));
      validateField(emailAddress).using(new NotEmptyValidator("Please enter your email address"));

      // and some water marks for fun
      watermark(firstName).with("Required");
      watermark(lastName).with("Required");
      watermark(emailAddress).with("Required");

   }

   public void setContact(Contact contact)
   {
      // clear any previous validation state.
      getValidationManager(this).clear();
      // and update all our value models
      contactProvider.setBean(contact);
   }

   public void commit()
   {
      contactProvider.commit();
   }

   public boolean validate()
   {
      return getValidationManager(this).validate();
   }
}
}}}